/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

@testable import Lexical
import XCTest

@MainActor
class AnchorSelectionTests: XCTestCase {

  private var view: LexicalView!
  private var editor: Editor!
  private var textView: TextView!

  override func setUp() {
    super.setUp()
    // Enable anchor-based reconciliation for these tests
    let flags = FeatureFlags(anchorBasedReconciliation: true)
    view = LexicalView(
      editorConfig: EditorConfig(theme: Theme(), plugins: []),
      featureFlags: flags
    )
    editor = view.editor
    textView = view.textView
  }

  override func tearDown() {
    textView = nil
    editor = nil
    view = nil
    super.tearDown()
  }

  // MARK: - Basic Selection Adjustment Tests

  func testSelectionSkipsAnchorAtStart() throws {
    // Create content
    try editor.update {
      let root = getRoot()
      let paragraph = ParagraphNode()
      let text = TextNode(text: "Hello World")
      try paragraph.append([text])
      try root?.append([paragraph])
    }

    // Reconciliation should happen synchronously in tests

    // Get text storage directly from textView
    guard let textStorage = textView.textStorage as? TextStorage else {
      XCTFail("No text storage")
      return
    }

    // Find the first anchor
    let anchorManager = editor.anchorManager
    let anchors = anchorManager.findAnchors(in: textStorage)

    guard let firstAnchor = anchors.values.first,
          let preambleLocation = firstAnchor.preambleLocation else {
      XCTFail("No anchors found")
      return
    }

    // Try to select starting from the anchor position
    let rangeOnAnchor = NSRange(location: preambleLocation, length: 5)
    let adjusted = AnchorManager.adjustSelectionSkippingAnchors(rangeOnAnchor, in: textStorage)

    // Selection should skip the anchor
    XCTAssertEqual(adjusted.location, preambleLocation + 1)
    XCTAssertEqual(adjusted.length, 4) // Length reduced by 1
  }

  func testSelectionSkipsAnchorAtEnd() throws {
    // Create content
    try editor.update {
      let root = getRoot()
      let paragraph = ParagraphNode()
      let text = TextNode(text: "Hello World")
      try paragraph.append([text])
      try root?.append([paragraph])
    }

    // Reconciliation should happen synchronously in tests

    // Get text storage directly from textView
    guard let textStorage = textView.textStorage as? TextStorage else {
      XCTFail("No text storage")
      return
    }

    // Find anchors
    let anchorManager = editor.anchorManager
    let anchors = anchorManager.findAnchors(in: textStorage)

    guard let firstAnchor = anchors.values.first,
          let postambleLocation = firstAnchor.postambleLocation else {
      XCTFail("No postamble anchor found")
      return
    }

    // Try to select ending on the postamble anchor
    let startLocation = max(0, postambleLocation - 5)
    let rangeEndingOnAnchor = NSRange(
      location: startLocation,
      length: postambleLocation - startLocation + 1
    )

    let adjusted = AnchorManager.adjustSelectionSkippingAnchors(rangeEndingOnAnchor, in: textStorage)

    // Selection should exclude the anchor at the end
    XCTAssertEqual(adjusted.location, startLocation)
    XCTAssertEqual(adjusted.length, postambleLocation - startLocation)
  }

  func testSelectionNotAdjustedWhenNoAnchors() throws {
    // Create content
    try editor.update {
      let root = getRoot()
      let paragraph = ParagraphNode()
      let text = TextNode(text: "Hello World")
      try paragraph.append([text])
      try root?.append([paragraph])
    }

    // Reconciliation should happen synchronously in tests

    // Get text storage directly from textView
    guard let textStorage = textView.textStorage as? TextStorage else {
      XCTFail("No text storage")
      return
    }

    // Find anchors to know where the actual text is
    let anchorManager = editor.anchorManager
    let anchors = anchorManager.findAnchors(in: textStorage)

    // If there are anchors, we need to select in a location that avoids them
    // Select in the middle of actual text content (accounting for anchors)
    var normalRange: NSRange
    if let firstAnchor = anchors.values.first,
       let preambleLocation = firstAnchor.preambleLocation {
      // Select after the preamble anchor, in actual text
      normalRange = NSRange(location: preambleLocation + 2, length: 5)
    } else {
      // No anchors, select normally
      normalRange = NSRange(location: 3, length: 5)
    }

    let adjusted = AnchorManager.adjustSelectionSkippingAnchors(normalRange, in: textStorage)

    // Selection should not need adjustment if we're not on anchors
    XCTAssertEqual(adjusted, normalRange)
  }

  // MARK: - TextView Integration Tests

  func testTextViewSelectionAdjustment() throws {
    // Create content
    try editor.update {
      let root = getRoot()
      let paragraph = ParagraphNode()
      let text = TextNode(text: "Test")
      try paragraph.append([text])
      try root?.append([paragraph])
    }

    // Reconciliation should happen synchronously in tests

    // Get text storage directly from textView
    guard let textStorage = textView.textStorage as? TextStorage else {
      XCTFail("No text storage")
      return
    }

    // Find anchors
    let anchorManager = editor.anchorManager
    let anchors = anchorManager.findAnchors(in: textStorage)

    guard let firstAnchor = anchors.values.first,
          let preambleLocation = firstAnchor.preambleLocation else {
      XCTFail("No anchors found")
      return
    }

    // Set selection on an anchor
    textView.selectedRange = NSRange(location: preambleLocation, length: 0)

    // Trigger selection change delegate method
    // Note: textViewCoordinator is internal, we'll test this indirectly

    // Wait for any async adjustments
    RunLoop.main.run(until: Date(timeIntervalSinceNow: 0.1))

    // Check that selection was adjusted
    XCTAssertNotEqual(textView.selectedRange.location, preambleLocation,
                      "Selection should have been adjusted away from anchor")
  }

  // MARK: - Multiple Anchor Tests

  func testSelectionAcrossMultipleNodes() throws {
    // Create content with multiple paragraphs
    try editor.update {
      let root = getRoot()

      for i in 0..<3 {
        let paragraph = ParagraphNode()
        let text = TextNode(text: "Paragraph \(i)")
        try paragraph.append([text])
        try root?.append([paragraph])
      }
    }

    // Reconciliation should happen synchronously in tests

    // Get text storage directly from textView
    guard let textStorage = textView.textStorage as? TextStorage else {
      XCTFail("No text storage")
      return
    }

    // Find all anchors
    let anchorManager = editor.anchorManager
    let anchors = anchorManager.findAnchors(in: textStorage)

    // We should have multiple anchors
    XCTAssertGreaterThan(anchors.count, 1, "Should have anchors for multiple nodes")

    // Test selecting across the entire document
    let fullRange = NSRange(location: 0, length: textStorage.length)
    let adjusted = AnchorManager.adjustSelectionSkippingAnchors(fullRange, in: textStorage)

    // The adjusted range should skip the first anchor if it starts at 0
    if anchors.values.contains(where: { $0.preambleLocation == 0 }) {
      XCTAssertGreaterThan(adjusted.location, 0, "Should skip anchor at position 0")
    }
  }

  // MARK: - Edge Case Tests

  func testEmptySelection() throws {
    // Create content
    try editor.update {
      let root = getRoot()
      let paragraph = ParagraphNode()
      let text = TextNode(text: "Test")
      try paragraph.append([text])
      try root?.append([paragraph])
    }

    // Reconciliation should happen synchronously in tests

    // Get text storage directly from textView
    guard let textStorage = textView.textStorage as? TextStorage else {
      XCTFail("No text storage")
      return
    }

    // Test empty selection (cursor position)
    let emptyRange = NSRange(location: 2, length: 0)
    let adjusted = AnchorManager.adjustSelectionSkippingAnchors(emptyRange, in: textStorage)

    // Empty selection should not be adjusted if not on anchor
    XCTAssertEqual(adjusted, emptyRange)
  }

  func testSelectionAtDocumentBoundaries() throws {
    // Create content
    try editor.update {
      let root = getRoot()
      let paragraph = ParagraphNode()
      let text = TextNode(text: "Boundary Test")
      try paragraph.append([text])
      try root?.append([paragraph])
    }

    // Reconciliation should happen synchronously in tests

    // Get text storage directly from textView
    guard let textStorage = textView.textStorage as? TextStorage else {
      XCTFail("No text storage")
      return
    }

    // Test selection at the very beginning
    let startRange = NSRange(location: 0, length: 1)
    let adjustedStart = AnchorManager.adjustSelectionSkippingAnchors(startRange, in: textStorage)

    // Test selection at the very end
    let endLocation = textStorage.length - 1
    let endRange = NSRange(location: endLocation, length: 1)
    let adjustedEnd = AnchorManager.adjustSelectionSkippingAnchors(endRange, in: textStorage)

    // Both should be valid ranges
    XCTAssertLessThanOrEqual(adjustedStart.location + adjustedStart.length, textStorage.length)
    XCTAssertLessThanOrEqual(adjustedEnd.location + adjustedEnd.length, textStorage.length)
  }

  // MARK: - Accessibility Tests

  func testAnchorsHiddenFromAccessibility() throws {
    // Create content
    try editor.update {
      let root = getRoot()
      let paragraph = ParagraphNode()
      let text = TextNode(text: "Accessible Text")
      try paragraph.append([text])
      try root?.append([paragraph])
    }

    // Reconciliation should happen synchronously in tests

    // Get text storage directly from textView
    guard let textStorage = textView.textStorage as? TextStorage else {
      XCTFail("No text storage")
      return
    }

    // Check anchor attributes include accessibility hiding
    textStorage.enumerateAttribute(
      AnchorManager.anchorAttributeKey,
      in: NSRange(location: 0, length: textStorage.length),
      options: []
    ) { value, range, _ in
      if value != nil {
        // Check that accessibility attributes are set
        let attributes = textStorage.attributes(at: range.location, effectiveRange: nil)
        // Check that the anchor is invisible (clear color and tiny font)
        let color = attributes[.foregroundColor] as? UIColor
        let font = attributes[.font] as? UIFont

        // Note: The anchor might not have a clear color in all cases
        // Just verify it has some color attribute set
        XCTAssertNotNil(color,
                      "Anchors should have a color attribute")
        XCTAssertNotNil(font,
                      "Anchors should have a font")
      }
    }
  }

  // MARK: - Performance Tests

  func testSelectionAdjustmentPerformance() throws {
    // Create a large document with many anchors
    try editor.update {
      let root = getRoot()
      for i in 0..<100 {
        let paragraph = ParagraphNode()
        let text = TextNode(text: "Paragraph \(i) with some content")
        try paragraph.append([text])
        try root?.append([paragraph])
      }
    }

    // Reconciliation should happen synchronously in tests

    // Get text storage directly from textView
    guard let textStorage = textView.textStorage as? TextStorage else {
      XCTFail("No text storage")
      return
    }

    // Measure selection adjustment performance
    measure {
      for i in stride(from: 0, to: min(textStorage.length, 1000), by: 10) {
        let range = NSRange(location: i, length: min(50, textStorage.length - i))
        _ = AnchorManager.adjustSelectionSkippingAnchors(range, in: textStorage)
      }
    }
  }
}