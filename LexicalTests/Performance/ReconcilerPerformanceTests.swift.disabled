/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

@testable import Lexical
import XCTest

@MainActor
class ReconcilerPerformanceTests: XCTestCase {

  // MARK: - Performance Benchmarks

  func testLegacyVsOptimizedReconcilerPerformance() throws {
    let documentSizes = [100, 500, 1000, 2000]

    for size in documentSizes {
      print("Testing document size: \(size) paragraphs")

      // Test legacy reconciler
      let legacyMetrics = try measureLegacyReconciler(paragraphs: size)

      // Test optimized reconciler
      let optimizedMetrics = try measureOptimizedReconciler(paragraphs: size)

      print("Legacy: \(legacyMetrics.averageDuration)ms, Optimized: \(optimizedMetrics.averageDuration)ms")
      print("Improvement: \(legacyMetrics.averageDuration / optimizedMetrics.averageDuration)x faster")

      // Optimized should be significantly faster for large documents
      if size >= 500 {
        XCTAssertLessThan(optimizedMetrics.averageDuration, legacyMetrics.averageDuration,
                         "Optimized reconciler should be faster for \(size) paragraphs")
      }
    }
  }

  func testTopInsertionPerformance() throws {
    let documentSize = 1000

    // Measure legacy reconciler for top insertion
    let legacyTime = try measureTopInsertion(paragraphs: documentSize, useOptimized: false)

    // Measure optimized reconciler for top insertion
    let optimizedTime = try measureTopInsertion(paragraphs: documentSize, useOptimized: true)

    print("Top insertion (\(documentSize) paragraphs):")
    print("Legacy: \(legacyTime)ms, Optimized: \(optimizedTime)ms")
    print("Improvement: \(legacyTime / optimizedTime)x faster")

    // This is the key performance improvement - top insertion should be much faster
    XCTAssertLessThan(optimizedTime, legacyTime * 0.5,
                     "Optimized reconciler should be at least 2x faster for top insertion")
  }

  func testMiddleEditPerformance() throws {
    let documentSize = 1000

    // Measure legacy reconciler for middle edit
    let legacyTime = try measureMiddleEdit(paragraphs: documentSize, useOptimized: false)

    // Measure optimized reconciler for middle edit
    let optimizedTime = try measureMiddleEdit(paragraphs: documentSize, useOptimized: true)

    print("Middle edit (\(documentSize) paragraphs):")
    print("Legacy: \(legacyTime)ms, Optimized: \(optimizedTime)ms")

    // Middle edits should also benefit from optimization
    XCTAssertLessThan(optimizedTime, legacyTime,
                     "Optimized reconciler should be faster for middle edits")
  }

  func testBulkOperationsPerformance() throws {
    let documentSize = 500
    let bulkOperations = 50

    // Test bulk delete performance
    let legacyBulkTime = try measureBulkOperations(paragraphs: documentSize, operations: bulkOperations, useOptimized: false)
    let optimizedBulkTime = try measureBulkOperations(paragraphs: documentSize, operations: bulkOperations, useOptimized: true)

    print("Bulk operations (\(bulkOperations) ops on \(documentSize) paragraphs):")
    print("Legacy: \(legacyBulkTime)ms, Optimized: \(optimizedBulkTime)ms")

    // Bulk operations might favor legacy due to fallback, but should not be significantly slower
    XCTAssertLessThan(optimizedBulkTime, legacyBulkTime * 2,
                     "Optimized reconciler should not be more than 2x slower for bulk operations")
  }

  // MARK: - Scaling Performance Tests

  func testScalingPerformance() throws {
    let sizes = [100, 200, 500, 1000, 2000]
    var legacyTimes: [Double] = []
    var optimizedTimes: [Double] = []

    for size in sizes {
      let legacyTime = try measureMiddleEdit(paragraphs: size, useOptimized: false)
      let optimizedTime = try measureMiddleEdit(paragraphs: size, useOptimized: true)

      legacyTimes.append(legacyTime)
      optimizedTimes.append(optimizedTime)

      print("Size \(size): Legacy \(legacyTime)ms, Optimized \(optimizedTime)ms")
    }

    // Verify O(log n) vs O(n) scaling
    let legacyGrowth = legacyTimes.last! / legacyTimes.first!
    let optimizedGrowth = optimizedTimes.last! / optimizedTimes.first!

    print("Growth factor (20x size increase):")
    print("Legacy: \(legacyGrowth)x, Optimized: \(optimizedGrowth)x")

    // Optimized should scale much better than legacy
    XCTAssertLessThan(optimizedGrowth, legacyGrowth * 0.7,
                     "Optimized reconciler should scale better than legacy")
  }

  // MARK: - Memory Performance Tests

  func testMemoryUsage() throws {
    let documentSize = 1000

    // Test memory usage with legacy reconciler
    let legacyMemory = try measureMemoryUsage(paragraphs: documentSize, useOptimized: false)

    // Test memory usage with optimized reconciler
    let optimizedMemory = try measureMemoryUsage(paragraphs: documentSize, useOptimized: true)

    print("Memory usage (\(documentSize) paragraphs):")
    print("Legacy: \(legacyMemory)MB, Optimized: \(optimizedMemory)MB")

    // Optimized should use similar or less memory
    XCTAssertLessThanOrEqual(optimizedMemory, legacyMemory * 1.2,
                            "Optimized reconciler should not use significantly more memory")
  }

  // MARK: - Helper Methods

  private func measureLegacyReconciler(paragraphs: Int) throws -> ReconcilerBenchmarkResult {
    let featureFlags = FeatureFlags(optimizedReconciler: false, reconcilerMetrics: true)
    return try measureReconcilerPerformance(paragraphs: paragraphs, featureFlags: featureFlags)
  }

  private func measureOptimizedReconciler(paragraphs: Int) throws -> ReconcilerBenchmarkResult {
    let featureFlags = FeatureFlags(optimizedReconciler: true, reconcilerMetrics: true)
    return try measureReconcilerPerformance(paragraphs: paragraphs, featureFlags: featureFlags)
  }

  private func measureReconcilerPerformance(paragraphs: Int, featureFlags: FeatureFlags) throws -> ReconcilerBenchmarkResult {
    let metrics = BenchmarkMetricsContainer()
    let editorConfig = EditorConfig(theme: Theme(), plugins: [], featureFlags: featureFlags, metricsContainer: metrics)
    let textKitContext = LexicalReadOnlyTextKitContext(editorConfig: editorConfig, featureFlags: featureFlags)
    let editor = textKitContext.editor

    // Create large document
    try editor.update {
      guard let rootNode = getActiveEditorState()?.getRootNode() else {
        XCTFail("No root node")
        return
      }

      for index in 0..<paragraphs {
        let paragraph = ParagraphNode()
        let textNode = TextNode(text: "Paragraph \(index) with some content to make it realistic", key: nil)
        try paragraph.append([textNode])
        try rootNode.append([paragraph])
      }
    }

    // Perform edits and measure
    let iterations = 10
    var durations: [TimeInterval] = []

    for _ in 0..<iterations {
      metrics.resetMetrics()

      let startTime = CFAbsoluteTimeGetCurrent()

      try editor.update {
        guard let rootNode = getActiveEditorState()?.getRootNode() else { return }
        let children = rootNode.getChildren()
        if let firstParagraph = children.first as? ParagraphNode {
          let textNode = TextNode(text: "Modified text content", key: nil)
          try firstParagraph.clear()
          try firstParagraph.append([textNode])
        }
      }

      let endTime = CFAbsoluteTimeGetCurrent()
      durations.append((endTime - startTime) * 1000) // Convert to milliseconds
    }

    let averageDuration = durations.reduce(0, +) / Double(durations.count)
    let minDuration = durations.min() ?? 0
    let maxDuration = durations.max() ?? 0

    return ReconcilerBenchmarkResult(
      averageDuration: averageDuration,
      minDuration: minDuration,
      maxDuration: maxDuration,
      iterations: iterations,
      paragraphs: paragraphs
    )
  }

  private func measureTopInsertion(paragraphs: Int, useOptimized: Bool) throws -> Double {
    let featureFlags = FeatureFlags(optimizedReconciler: useOptimized, reconcilerMetrics: true)
    let metrics = BenchmarkMetricsContainer()
    let editorConfig = EditorConfig(theme: Theme(), plugins: [], featureFlags: featureFlags, metricsContainer: metrics)
    let textKitContext = LexicalReadOnlyTextKitContext(editorConfig: editorConfig, featureFlags: featureFlags)
    let editor = textKitContext.editor

    // Create large document
    try editor.update {
      guard let rootNode = getActiveEditorState()?.getRootNode() else { return }
      for index in 0..<paragraphs {
        let paragraph = ParagraphNode()
        let textNode = TextNode(text: "Paragraph \(index)", key: nil)
        try paragraph.append([textNode])
        try rootNode.append([paragraph])
      }
    }

    // Measure top insertion
    let startTime = CFAbsoluteTimeGetCurrent()

    try editor.update {
      guard let rootNode = getActiveEditorState()?.getRootNode() else { return }
      let newParagraph = ParagraphNode()
      let textNode = TextNode(text: "NEW TOP PARAGRAPH", key: nil)
      try newParagraph.append([textNode])
      try rootNode.append([newParagraph])
    }

    let endTime = CFAbsoluteTimeGetCurrent()
    return (endTime - startTime) * 1000 // Convert to milliseconds
  }

  private func measureMiddleEdit(paragraphs: Int, useOptimized: Bool) throws -> Double {
    let featureFlags = FeatureFlags(optimizedReconciler: useOptimized, reconcilerMetrics: true)
    let metrics = BenchmarkMetricsContainer()
    let editorConfig = EditorConfig(theme: Theme(), plugins: [], featureFlags: featureFlags, metricsContainer: metrics)
    let textKitContext = LexicalReadOnlyTextKitContext(editorConfig: editorConfig, featureFlags: featureFlags)
    let editor = textKitContext.editor

    // Create large document
    try editor.update {
      guard let rootNode = getActiveEditorState()?.getRootNode() else { return }
      for index in 0..<paragraphs {
        let paragraph = ParagraphNode()
        let textNode = TextNode(text: "Paragraph \(index)", key: nil)
        try paragraph.append([textNode])
        try rootNode.append([paragraph])
      }
    }

    // Measure middle edit
    let startTime = CFAbsoluteTimeGetCurrent()

    try editor.update {
      guard let rootNode = getActiveEditorState()?.getRootNode() else { return }
      let children = rootNode.getChildren()
      let middleIndex = paragraphs / 2
      if let middleParagraph = children[middleIndex] as? ParagraphNode {
        let textNode = TextNode(text: "MODIFIED MIDDLE PARAGRAPH", key: nil)
        try middleParagraph.clear()
        try middleParagraph.append([textNode])
      }
    }

    let endTime = CFAbsoluteTimeGetCurrent()
    return (endTime - startTime) * 1000 // Convert to milliseconds
  }

  private func measureBulkOperations(paragraphs: Int, operations: Int, useOptimized: Bool) throws -> Double {
    let featureFlags = FeatureFlags(optimizedReconciler: useOptimized, reconcilerMetrics: true)
    let metrics = BenchmarkMetricsContainer()
    let editorConfig = EditorConfig(theme: Theme(), plugins: [], featureFlags: featureFlags, metricsContainer: metrics)
    let textKitContext = LexicalReadOnlyTextKitContext(editorConfig: editorConfig, featureFlags: featureFlags)
    let editor = textKitContext.editor

    // Create large document
    try editor.update {
      guard let rootNode = getActiveEditorState()?.getRootNode() else { return }
      for index in 0..<paragraphs {
        let paragraph = ParagraphNode()
        let textNode = TextNode(text: "Paragraph \(index)", key: nil)
        try paragraph.append([textNode])
        try rootNode.append([paragraph])
      }
    }

    // Measure bulk operations
    let startTime = CFAbsoluteTimeGetCurrent()

    try editor.update {
      guard let rootNode = getActiveEditorState()?.getRootNode() else { return }
      let children = rootNode.getChildren()

      // Remove every other paragraph for the specified number of operations
      for i in 0..<min(operations, children.count) {
        if i * 2 < children.count {
          try children[i * 2].remove()
        }
      }
    }

    let endTime = CFAbsoluteTimeGetCurrent()
    return (endTime - startTime) * 1000 // Convert to milliseconds
  }

  private func measureMemoryUsage(paragraphs: Int, useOptimized: Bool) throws -> Double {
    let featureFlags = FeatureFlags(optimizedReconciler: useOptimized, reconcilerMetrics: true)
    let metrics = BenchmarkMetricsContainer()
    let editorConfig = EditorConfig(theme: Theme(), plugins: [], featureFlags: featureFlags, metricsContainer: metrics)
    let textKitContext = LexicalReadOnlyTextKitContext(editorConfig: editorConfig, featureFlags: featureFlags)
    let editor = textKitContext.editor

    let startMemory = getCurrentMemoryUsage()

    // Create large document
    try editor.update {
      guard let rootNode = getActiveEditorState()?.getRootNode() else { return }
      for index in 0..<paragraphs {
        let paragraph = ParagraphNode()
        let textNode = TextNode(text: "Paragraph \(index) with content", key: nil)
        try paragraph.append([textNode])
        try rootNode.append([paragraph])
      }
    }

    let endMemory = getCurrentMemoryUsage()
    return (endMemory - startMemory) / (1024 * 1024) // Convert to MB
  }

  private func getCurrentMemoryUsage() -> Double {
    var info = mach_task_basic_info()
    var count = mach_msg_type_number_t(MemoryLayout<mach_task_basic_info>.size)/4

    let kerr = withUnsafeMutablePointer(to: &info) {
      $0.withMemoryRebound(to: integer_t.self, capacity: 1) {
        task_info(mach_task_self_, task_flavor_t(MACH_TASK_BASIC_INFO), $0, &count)
      }
    }

    if kerr == KERN_SUCCESS {
      return Double(info.resident_size)
    }
    return 0.0
  }
}

// MARK: - Supporting Types

struct ReconcilerBenchmarkResult {
  let averageDuration: Double
  let minDuration: Double
  let maxDuration: Double
  let iterations: Int
  let paragraphs: Int
}

@MainActor
class BenchmarkMetricsContainer: EditorMetricsContainer {
  private(set) var reconcilerRuns: [ReconcilerMetric] = []
  private(set) var optimizedReconcilerRuns: [OptimizedReconcilerMetric] = []
  var metricsData: [String: Any] = [:]

  func record(_ metric: EditorMetric) {
    switch metric {
    case .reconcilerRun(let data):
      reconcilerRuns.append(data)
    case .optimizedReconcilerRun(let data):
      optimizedReconcilerRuns.append(data)
    }
  }

  func resetMetrics() {
    reconcilerRuns.removeAll()
    optimizedReconcilerRuns.removeAll()
    metricsData.removeAll()
  }
}